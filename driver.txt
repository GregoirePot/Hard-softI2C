
library ieee;
use IEEE.STD_LOGIC_1164.ALL;    

entity driver is
	generic (
	Address : in STD_LOGIC_VECTOR(6 downto 0) := "1001000"   
	);
	port (                                                     
	CLK :in  STD_LOGIC;     
	SDA_in  : in  STD_LOGIC;
	SDA_out : out STD_LOGIC;
	SCL     : in  STD_LOGIC; 
	Temp_h  :  in std_logic_vector(7 downto 0);     
	Temp_l  :  in std_logic_vector(7 downto 0);     
	Reset   : in  STD_LOGIC                               
	);
end driver;

architecture Behavioral of driver is
	type State is (Idle, AddressMatched, ACK_write, ACK_read,ACK_read2, reg_address, ReceiveData,ACK_write2,ReceiveData2, ACKMaster, ACKMaster2);               
	signal CurrentState : State := Idle;                             
	signal BitCounter   : integer range 0 to 7 := 0;                    
	signal DataReg      : STD_LOGIC_VECTOR(7 downto 0);                   
	signal ReceivedAddress : STD_LOGIC_VECTOR(7 downto 0);              
	signal data         : STD_LOGIC_VECTOR(7 downto 0);                  
	signal data1 : std_logic_vector(7 downto 0);         
	signal data2 : std_logic_vector(7 downto 0);         
 
	begin


	process (SCL, Reset) 
		begin    
		if Reset = '1' then
			CurrentState <= Idle; 
			BitCounter <= 0;
			SDA_out <= '1';       

		elsif rising_edge(SCL) then 
			SDA_out <= '1';     


			case CurrentState is               
 
			when Idle =>                
			
				data1 <=  Temp_h;  
				data2 <=  Temp_l;
				SDA_out<='1';

				if SDA_in ='0' then 
					CurrentState <= AddressMatched;    
					BitCounter<=0;                      
				end if;
				

			when AddressMatched =>
				ReceivedAddress(7-BitCounter) <= SDA_in;  

				if BitCounter = 7 then 
					BitCounter <= 0; 
					if ReceivedAddress(7 downto 1) = Address then 
						if SDA_in = '0' then    
							CurrentState <= ACK_write;
						else  
							CurrentState <= ACK_read; 


						end if;
					
					end if;
				else
					BitCounter <= BitCounter + 1;											 
				end if;

			when ACK_read =>            
				SDA_out <= '0'; 
				BitCounter <= 0;
				CurrentState <= ACK_read2; 
		

			when ACK_write =>     
				SDA_out <= '0';    
				BitCounter <= 0;
				CurrentState <= reg_address;
				

			when reg_address =>
				
				SDA_out<='1';
				data(7 - BitCounter) <= SDA_in;
				if BitCounter = 7 then              
					CurrentState <= ACK_write2;
				
				else                               
					BitCounter <= BitCounter + 1;

				end if;
				

			when ACK_write2 =>                 
				SDA_out <= '0'; 
				BitCounter <= 0;
				CurrentState <= Idle; 


			when ACK_read2 =>     
			SDA_out<='1'; 
			CurrentState<=ReceiveData; 
			when ReceiveData =>
	
			SDA_out<= data1(7-BitCounter); 
			if BitCounter = 7 then
				SDA_out<= data1(0);
				CurrentState <= ACKMaster; 
				
			else
				BitCounter <= BitCounter + 1;   
			end if;
			 

			when ACKMaster =>  
			BitCounter <=0;
			if SDA_in = '0' then 
				CurrentState <= ReceiveData2; 
			end if;

			when ReceiveData2 =>
			
				SDA_out<= data2(7-BitCounter); 
				
				if BitCounter = 7 then
					SDA_out<= data1(0);
					CurrentState <= ACKMaster2; 
				else
				BitCounter <= BitCounter + 1;
				end if;


			when ACKMaster2 =>
				BitCounter<=0;
				if SDA_in = '0' then 
					CurrentState <= Idle;
					BitCounter <=0;

				end if;	


			when others =>
			CurrentState <= Idle; 
			BitCounter <= 0;

			end case;
		end if;
		

	end process;




end Behavioral;
